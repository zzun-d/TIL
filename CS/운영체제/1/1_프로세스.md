## 1. 프로세스의 개념



- 하나의 작업 단위
- 하나의 프로그램을 사용자가 실행하면 그 프로그램은 프로세스가 됨
- 폰노이만 구조에서 프로그램은 저장장치에 있는 정적인 상태
- 프로세스는 프로그램이 실행을 위하여 메모리에 올라온 동적인 상태

## 2. 요리 비유

- **요리사 → CPU**
- **레시피 → 프로그램**
- **주문서 → 실행할 프로그램들의 목록(PCB)**
    - 코스 요리 A
    - 가격
    - 애피타이저(새송이 스프)
    - 메인 디쉬(스테이크)
    - 디저트(커피)

- **요리 과정 → 프로세스**
    - 재료손질(버섯, 고기, 원두)
    - 요리
    - 서빙
    - 테이블 정리

- **일괄 작업 시스템(요리 비유)**
    - 테이블이 하나뿐인 식당
    - 주문은 한번에 하나씩만 들어오며 주문된 요리가 모두 완료되어야 다음 주문이 가능
    - 고객이 식사를 다 하고 나가야 새로운 손님의 주문서를 받을 수 있음
    - 효율이 떨어짐(요리사가 노는 시간이 발생)
    
    - 일괄 작업 방식에서 기다리는 손님들에게 미리 주문서를 받는 것을 가정하면
    - 주문 목록이 생성됨
        - 생성된 주문 목록은 먼저 들어온 주문서가 먼저 처리되는 형식(queue)

- **시분할 시스템(요리 비유)**
    - 테이블이 여러개인 식당은 한번에 여러 손님을 받을 수 있음
    - 1번 손님이 애피타이저를 먹는동안 2번 손님의 애피타이저 요리
        - 1번 손님의 주문서는 주문 목록 맨 뒤로 이동
    - 요리사는 1명이지만 손님의 식사시간을 잘 활용하여 한번에 여러명의 손님을 응대 가능
    - CPU가 1대인 컴퓨터에서 여러 프로세스를 동시에 실행하는 원리

- **주문서의 역할**
    - 주문서가 주문 목록에 올라오는 것은 요리의 시작(프로세스의 시작)
    - 주문서는 주문 목록에서 대기하거나 요리사에게 넘겨져 요리가 되는 상태 왕복
    - 요리의 모든 작업이 끝나면 주문서 폐기(프로세스 종료)

- **시분할 시스템에서 예상치 못한 상황 처리**
    - 손님이 주문한 음식의 재료 손질이 덜 된 경우
    - 손질이 끝날 때까지 기다렸다가 요리를 진행하면 비효율적
    - 재료손질이 덜된 주문서는 재료손질이 끝날때까지 잠시 대기목록에 둠
    - 이후 다음 주문서를 처리하며, 재료손질이 끝나면 대기목록에서 다시 주문목록으로
    - 또한, 고객이 요리를 늦게 달라고 요청하거나 주문을 취소할 수도 있음
    - 요리 지연 요청이 들어오면 우선 보류 목록에 추가
    - 보류 목록에 있는 주문서들은 언제 다시 시작될지 모름(폐기 가능성도 있음)

## 3. 프로그램에서 프로세스로의 전환

- 프로세스는 컴퓨터 시스템의 작업 단위로 task라고도 불림
- 프로그램을 실행하면 우선 운영체제는 프로그램을 메모리로 올림
- 동시에 주문서에 해당하는 작업 지시서를 생성
    - **작업 지시서 -> 프로세스 제어 블록(Process Contol Block)**
- 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 않음
- 프로세스 제어블록
    - **프로세스 구분자**
        - 메모리에 존재하는 여러 프로세스를 구분하는 역할
    - **메모리 관련 정보**
        - 프로세스가 메모리의 어느 부분에 저장 되어있는지 알아야 CPU가 작업 가능
    - **각종 중간 값**
        - 프로세스가 사용했던 중간 값이 저장
        - 손님에게 애피타이저가 나갔는지, 재료 손질 중은 아닌지
- 정리하면, 운영체제로부터 프로세스 제어 블록을 얻으면 프로그램 -> 프로세스
- 프로세스 제어 블록이 폐기 된다는 것은 프로세스의 종료를 의미

> 💡하나의 프로세스를 실행하기 위해서는 **프로세스 구분자**, **메모리 관련 정보, 각종 중간 값**을 관리해야 하고, 이 정보들을 보관하는 데이터 구조가 **PCB**이다.
> 프로그램이 프로세스가 되기 위해선 프로그램이 **메모리에 올라옴**과 동시에 
**PCB가 생성**되어야 한다.


## 4. 프로세스의 상태

- **일괄 작업 시스템**
    - 프로세스가 생성되고, CPU를 받아 작업을 마치면 종료
    - 생성, 실행, 완료 상태로 이루어짐
- **시분할 작업 시스템**
    - CPU의 이동이 빈번하기 때문에 일괄 작업 시스템보다 복잡함
    - 생성, 준비, 실행, 대기, 완료 상태로 이루어짐(추가로 보류 상태, 휴식 상태 존재)
    


- **생성 상태**
    - 프로세스가 메모리에 올라가 실행 준비를 마친 상태
    - PCB가 생성된다
- **준비 상태**
    - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- **실행 상태**
    - 준비 상태에 있던 프로세스 중 하나가 CPU를 얻어 실제 작업을 하는 상태
    - 일정 시간 동안 CPU를 사용하는데 정해진 시간이 끝나도 작업을 끝내지 못하면 다시 준비 상태로 돌아가 순서를 기다린다(time-out)
    - 프로세스는 작업을 완료할 때까지 준비 상태와 실행 상태를 왔다 갔다 한다.
- **대기 상태**
    - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태
    - 입출력이 완료되면 준비 상태로 돌아감
- **완료 상태(종료 상태)**
    - 실행 된 프로세스가 작업을 마치면 완료 상태가 된다
    - PCB 삭제
- **보류 상태(지연 상태)**
    - 프로세스가 메모리에서 잠시 쫒겨난 상태로 스왑 영역에 보관
        - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보내야 할 때
        - 프로그램에 오류가 있어서 실행을 미뤄야 할 떄
        - 악의적인 공격을 하는 프로세스라고 판단될 때(바이러스)
        - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
    
    - **보류 대기 상태(지연 대기 상태)**
        - 대기 상태에서 옮겨지면 보류 대기 상태로 구분
        - 보류에서 해제되어 재시작 되면 대기 상태로 돌아감
        - 보류 대기 중에 입출력이 끝나면 보류 준비 상태로 옮겨짐
    - **보류 준비 상태(지연 준비 상태)**
        - 준비 상태에서 옮겨지면 보류 준비 상태로 구분
        - 보류에서 해제되어 재시작 되면 준비 상태로 돌아감
- **휴식 상태**
    - 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 메모리에서 내려오지 않음(보류와 다른점)
    - 휴식 지점부터 재시작 할 수 있음

- **CPU 스케쥴러**
    - 다음으로 실행할 프로세스를 선정하는 역할
    - 준비 상태의 프로세스를 실행 상태로 바꾸는 작업을 디스패치(dispatch)라고 함

