# 5. 스택 2

## 계산기 1

- **문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다**
- **문자열 수식 계산의 일반적 방법**
    <br>
    - 1. 중위 표기법의 수식을 후위 표기법으로 변경
    - 2. 후위 표기법의 수식을 스택을 이용하여 계산

    <br>    

    **중위 표기법의 수식을 후위 표기법으로 변경하는 방법**
    <br>

    1. 중위표기식의 후위표기식 변환 방법1
        - 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
        - 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동
        - 괄호 제거
    <br>
    2. 중위 표기법에서 후위 표기법으로의 변환 알고리즘2
        - 입력 받은 중위 표기식에서 토큰 읽음
        - 토큰이 피연산자(숫자)면 토큰 출력
        - 토큰이 연산자면 이 토큰이 스택의 top 연산자 보다 우선순위가 높으면 스택에 push, 그렇지 않으면 stack top 연산자의 우선순위가 토큰의 우선순위보다 작을 때까지 스택에서 pop한 뒤 토큰 연산자를 push(top에 연산자 없으면 push)
        - 토큰이 닫는 괄호면 스택 top에 여는 괄호가 올 때 까지 pop & 출력, 이후 여는 괄호 만나면 pop하고 출력은 안함
        - 위 과정 반복

<br>

## 계산기 2

- **후위 표기법의 수식을 스택틀 이용하여 계산**
<br>

    - 피연산자 -> 스택에 push
    - 연산자 -> 필요한 만큼의 피연산자를 스택에서 pop하여 연산, 결과를 스택에 push
    - 수식이 끝나면, 마지막 스택 pop -> 출력

<br>

## 백트래킹

- **백트래킹 기법은 해를 찾는 도중에 막히면 되돌아가 다시 해를 찾는 기법**
- **최적화 문제, 결정 문제 해결에 사용 가능**
    - **결정 문제**
        - 문제의 조건을 만족하는 해가 존재하는지 여부를 yes, no로 답하는 문제
        - ex) 미로 찾기, 부분 집합의 합...

<br>

- **미로 찾기**
    - 입구와 출구가 정해진 배열에서 경로를 찾는 문제로 이동 가능 방향은 상하좌우로 제한
    - 스택을 이용하여 방문 정점, 경로 저장
<br>

- **백트래킹과 깊이 우선 탐색의 차이**
    - 어떤 정점에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로는 필요 없음
    - 깊이 우선 탐색은 모든 경로 추적, 백트래킹은 불필요한 경로 추적 안함
    - 깊이 우선 탐색은 N!의 경우의 수를 가짐
    - 백트래킹은 일반적으로 경우의 수를 줄여 줌

<br>

- **백트래킹을 이용한 알고리즘 절차**
1. 상태 공간 트리의 깊이 우선 탐색 실시
2. 노드의 유망성 탐색
3. 노드의 유망성이 없을 경우, 현재 경로를 버리고 부모 노드로 돌아감


<br>

## 부분 집합 구하기
- **어떤 집합의 공집합과 자기 자신을 포함한 모든 부분집합을 powerset이라 함**
- **백트래킹 기법으로 powerset을 구해보자**
    - 앞에서 설명한 일반적인 백트래킹 접근 방법을 이용
    <br>

    각 원소가 부분집합에 포함되었는지 loop를 이용하여 확인하고 부분집합 생성
    ```python
    bit = [0, 0, 0, 0]
    for i in range(2):
        bit[0] = i                  # 0번쨰 원소
        for j in range(2):
            bit[1] = j              # 1번째 원소
            for k in range(2):
                bit[2] = k          # 2번째 원소
                for l in range(2):
                    bit[3] = l      # 3번째 원소

                    print(bit)
    ```

    <br>

    powerset을 구하는 백트래킹 알고리즘
    ```python
    def backtrack(a, k, input):
        global MAXCANDIDATES
        c = [0] * MAXCANDIDATES
    
        if k == input:
            process_solution(a, k)  # 답이면 원하는 작업 실시
        else:
            k += 1
            ncandidates = construct_candidates(a, k, input, c)
            for i in range(ncandidates):
                a[k] = c[i]
                backtrack(a, k, input)
    
    def construct_candidates(a, k, input, c):
        c[0] = True
        c[1] = False
        return 2

    


    ```