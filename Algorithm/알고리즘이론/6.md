# 큐(Queue)

**큐의 특성**
- 스택과 마찬가지로 삽입, 삭제 위치가 제한적인 자료구조
    - 큐의 뒤에서는 삽입만, 앞에서는 삭제만 이뤄지는 구조

<br>


- 선입선출구조(FIFO : First In First Out)

    [머리, 원소1, 원소2 ... 원소n, 꼬리]
    머리 : 저장된 원소 중 첫 원소
    꼬리 : 저장된 원소 중 마지막 원소

<br>


- 큐의 사용을 위한 연산
    - enQueue(item) : 큐의 꼬리에 원소를 삽입
    - deQueue() : 큐의 머리를 삭제하고 반환
    - createQueue() : 공백 큐를 생성
    - isEmpty() : 큐가 공백인지 확인
    - isFull() : 큐가 포화상태인지 확인
    - Qpeek() : 큐의 머리를 삭제없이 반환


<br>

## 선형큐

- **1차원 배열을 이용한 큐**
    - 큐의 크기 == 배열의 크기
    - front: 저장된 첫 원소의 인덱스
    - rear: 저장된 마지막 원소 인덱스

<br>

- **상태표현**
    - 초기 상태 : fornt = rear = -1
    - 공백 상태 : fornt == rear
    - 포화 상태 : rear == n-1(n: 배열의 크기, n-1 배열의 마지막 인덱스)

<br>

- **초기 공백 큐 생성**
    - 크기 n인 1차원 배열 생성
    - front와 rear를 -1로 초기화

- **삽입: enQueue(item)**
    - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
        1) rear를 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
        2) 그 인덱스에 해당하는 배열원소 Q\[rear]에 item 저장

- **삭제: deQueue()**
    - 가장 앞에 있는 원소를 삭제
        1) front 값 하나 증가시켜 큐에 남아있게 될 첫 원소 이동
        2) 새로운 첫 원소를 리턴 함으로 삭제와 동일한 기능

- **공백상태 및 포화상태 검사: isEmpty(), isFull()**
    - 공백상태 : front == rear
    - 포화상태 : rear == n-1

- **검색**
    - 가장 앞에 있는 원소를 검색하여 반환하는 연산
    - 현재 front 인덱스보다 하나 뒤에 있는 원소를 반환(큐의 첫 원소)




## 원형큐

**원형 큐의 구조**

- 잘못된 포화상태 인식 해결 방법

    - 원소의 삽입과 삭제가 계속되면 앞부분이 비어있음에도 큐가 꽉찼다고 오해하는 경우 발생

- 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용
- **초기 공백 상태**
    - fornt = rear = 0

- **Index의 순환**
    - front와 rear의 위치가 배열의 마지막 인덱스인 n-1을 가리킨 후, 다음에는 논리적 순환을 이용하여 처음 인덱스인 0으로 돌아감
    - 이를 위해 나머지 연산자 mod를 사용

- **front 변수**
    - 공백 상태, 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠

- **삽입 위치 및 삭제 위치**
    - 선형큐
        - 삽입 위치 : rear = rear + 1
        - 삭제 위치 : front = front + 1
    - 원형큐
        - 삽입 위치 : rear = (rear + 1) % n
        - 삭제 위치 : front = (front + 1) % n

- **삽입 : enQueue(item)**
    - 마지막 원소 뒤에 새로운 원소 삽입
        1) rear값을 조정하여 새로운 원소가 들어갈 자리 마련
            rear = (rear + 1) % n
        2) 그 인덱스에 해당하는 배열 원소에 item 저장

- **삭제 : deQueue(), delete()**
    - 가장 앞에 있는 원소 삭제
        1) front 값을 조정하여 삭제할 자리 준비
        2) 새로운 front 원소를 리턴함으로 삭제와 동일한 기능


## 우선순위 큐
- **우선순위 큐의 특성**
    - 우선순위를 가진 항목들을 저장하는 큐
    - FIFO가 아니라 우선순위가 높은 순서대로 먼저 나간다

- **우선순위 큐의 적용 분야**
    - 시뮬레이션 시스템
    - 네트워크 트래픽 제어
    - 운영체제의 테스크 스케줄링

- **우선순위 큐의 구현**
    - 배열을 이용한 우선순위 큐
    - 리스트를 이용한 우선순위 큐

- **우선순위 큐의 기본 연산**
    - 삽입 : enQueue
    - 삭제 : deQueue

- **배열을 이용하여 우선순위 큐 구현**
    - 배열을 이용하여 자료 저장
    - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
    - 가장 앞에 최고 우선순위의 원소가 위치하게 됨

- **문제점**
    - 배열을 사용하므로 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생
    - 이에 소요되는 시간이나 메모리 낭비가 큼



## 버퍼
- **버퍼**
    - 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
    - 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작

- **버퍼의 자료 구조**
    - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
    - 순서대로 입력/출력/전달되어야 하므로 FIFO 방식의 자료구조인 큐가 활용



## BFS(Breadth First Search)
- **그래프를 탐색하는 방법에는 크게 두 가지가 존재**
    - 깊이 우선 탐색(DFS)
    - 너비 우선 탐색(BFS)
- **너비 우선 탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문 후에 방문했던 정점을 시작점으로 다시 인접한 정점을 차례로 방문하는 방식**
- **인접한 정점을 탐색 후에, 차례로 다시 너비우선 탐색을 진행하므로, FIFO구조인 Queue를 사용**
```python
def BFS(G, v):  # 그래프 G, 시작점 v
    visited = [0]*(n+1)     # n 정점의 개수
    queue = []
    queue.append(v)         # 큐에 시작점 삽입
    while queue:            # 큐가 비어있지 않으면
        t = queue.pop(0)        # 큐의 첫 원소 반환
        if not visited[t]:      # 방문되지 않은 곳이면
            visited[t] = True       # 방문으로 표시
            visit(t)                # 정점에서 할 일 지시
            for i in G[t]:          # t와 연결된 다른 모든 정점들 루프
                if not visited[i]:      # 방문되지 않은 곳이면
                    queue.append(i)         # 큐에 삽입
```

