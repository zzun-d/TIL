# 1. 프로세스의 개요
## 1.1 프로세스의 개념

![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/1.png?raw=true)
- 하나의 작업 단위
- 하나의 프로그램을 사용자가 실행하면 그 프로그램은 프로세스가 됨
- 폰노이만 구조에서 프로그램은 저장장치에 있는 정적인 상태
- 프로세스는 프로그램이 실행을 위하여 메모리에 올라온 동적인 상태


## 1.2 요리 비유
- 레시피 -> 프로그램
- 주문서 -> 실행할 프로그램들의 목록
    - 코스 요리 A
    - 가격
    - 애피타이저(새송이 스프)
    - 메인디쉬(스테이크)
    - 디저트(커피)
- 요리 과정 -> 프로세스
    - 재료손질(버섯, 고기, 원두)
    - 요리
    - 서빙
    - 테이블 정리
<br>

- 일괄 작업 시스템(요리 비유)
    - 테이블이 하나뿐인 식당
    - 주문은 한번에 하나씩만 들어오며 주문된 요리가 모두 완료되어야 다음 주문이 가능
    - 고객이 식사를 다 하고 나가야 새로운 손님의 주문서를 받을 수 있음
    - 효율이 떨어짐(요리사가 노는 시간이 발생)
    <br>

    - 일괄 작업 방식에서 기다리는 손님들에게 미리 주문서를 받는 것을 가정하면
    - 주문 목록이 생성됨
        - 생성된 주문 목록은 먼저 들어온 주문서가 먼저 처리되는 형식(queue)
- 시분할 시스템(요리 비유)
    - 테이블이 여러개인 식당은 한번에 여러 손님을 받을 수 있음
    - 1번 손님이 애피타이저를 먹는동안 2번 손님의 애피타이저 요리
    - 요리사는 1명이지만 손님의 식사시간을 잘 활용하여 한번에 여러명의 손님을 응대 가능
    - CPU가 1대인 컴퓨터에서 여러 프로세스를 동시에 실행하는 원리
- 주문서의 역할
    - 주문서가 주문 목록에 올라오는 것은 요리의 시작(프로세스의 시작)
    - 주문서는 주문 목록에서 대기하거나 요리사에게 넘겨져 요리가 되는 상태 왕복
    - 요리의 모든 작업이 끝나면 주문서 폐기(프로세스 종료)
    
- 시분할 시스템에서 예상치 못한 상황 처리
    - 손님이 주문한 음식의 재료 손질이 덜 된 경우
    - 손질이 끝날 때까지 기다렸다가 요리를 진행하면 비효율적
    - 재료손질이 덜된 주문서는 재료손질이 끝날때까지 잠시 대기목록에 둠
    - 이후 다음 주문서를 처리하며, 재료손질이 끝나면 대기목록에서 다시 주문목록으로
    - 또한, 고객이 요리를 늦게 달라고 요청하거나 주문을 취소할 수도 있음
    - 요리 지연 요청이 들어오면 우선 보류 목록에 추가
    - 보류 목록에 있는 주문서들은 언제 다시 시작될지 모름(폐기 가능성도 있음)

## 1.3 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 task라고도 불림
- 프로그램을 실행하면
- 우선 운영체제는 프로그램을 메모리로 올림
- 동시에 주문서에 해당하는 작업 지시서를 생성
- 작업 지시서 -> 프로세스 제어 블록(Process Contol Block)
- 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 않음
- 프로세스 제어블록
    - 프로세스 구분자
        - 메모리에 존재하는 여러 프로세스를 구분하는 역할
    - 메모리 관련 정보
        - 프로세스가 메모리의 어느 부분에 저장 되어있는지 알아야 CPU가 작업 가능
    - 각종 중간값:
        - 프로세스가 사용했던 중간값이 저장
        - 손님에게 애피타이저가 나갔는지, 재료 손질 중은 아닌지
- 정리하면, 운영체제로부터 프로세스 제어 블록을 얻으면 프로그램 -> 프로세스
- 프로세스 제어 블록이 폐기 된다는 것은 프로세스의 종료를 의미

## 1.4 프로세스의 상태
- **일괄 작업 시스템**
    - 프로세스가 생성되고, CPU를 받아 작업을 마치면 종료
    - 생성, 실행, 완료 단계로 이루어짐
- **시분할 작업 시스템**
    - CPU의 이동이 빈번하기 때문에 일괄 작업 시스템보다 복잡함
    - 생성, 준비, 실행, 대기, 완료 단계로 이루어짐(추가로 보류 상태, 휴식 상태 존재)
    
    ![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/2.png?raw=true)
    

- **생성 상태**
    - 프로세스가 메모리에 올라가 실행 준비를 마친 상태
    - PCB가 생성된다
- **준비 상태**
    - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- **실행 상태**
    - 준비 상태에 있던 프로세스 중 하나가 CPU를 얻어 실제 작업을 하는 상태
    - 일정 시간 동안 CPU를 사용하는데 정해진 시간이 끝나도 작업을 끝내지 못하면 다시 준비 상태로 돌아가 순서를 기다린다.
    - 프로세스는 작업을 완료할 때까지 준비 상태와 실행 상태를 왔다 갔다 한다.
- **대기 상태**
    - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태
    - 입출력이 완료되면 준비 상태로 돌아감
- **완료 상태(종료 상태)**
    - 실행 된 프로세스가 작업을 마치면 완료 상태가 된다
    - PCB 삭제
- **보류 상태(지연 상태)**
    - 프로세스가 메모리에서 잠시 쫒겨난 상태로 스왑 영역에 보관
        - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 내보내야 할 때
        - 프로그램에 오류가 있어서 실행을 미뤄야 할 떄
        - 악의적인 공격을 하는 프로세스라고 판단될 때(바이러스)
        - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
    
    - **보류 대기 상태(지연 대기 상태)**
        - 대기 상태에서 옮겨지면 보류 대기 상태로 구분
        - 보류에서 해제되어 재시작 되면 대기 상태로 돌아감
        - 보류 대기 중에 입출력이 끝나면 보류 준비 상태로 옮겨짐
    - **보류 준비 상태(지연 준비 상태)**
        - 준비 상태에서 옮겨지면 보류 준비 상태로 구분
        - 보류에서 해제되어 재시작 되면 준비 상태로 돌아감
- **휴식 상태**
    - 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 메모리에서 내려오지 않음(보류와 다른점)
    - 휴식 지점부터 재시작 할 수 있음

- **CPU 스케쥴러**
    - 다음으로 실행할 프로세스를 선정하는 역할
    - 준비 상태의 프로세스를 실행 상태로 바꾸는 작업을 디스패치(dispatch)라고 함
    
    ![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/2.png?raw=true)

    
----


## 1. 프로세스 제어 블록(PCB: Process Control Block)

: 프로세스를 실행하는 필요한 정보를 보관하는 자료구조(구조체)

: 프로세스 생성 시 만들어져서, 완료 시 폐기됨

![KakaoTalk_20220725_193739604_02.jpg](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/3.jpg?raw=true)

- **포인터**: 프로세스 제어블록을 연결할 때 사용 → Ex. 준비상태 큐(Queue) 구현
    - 대기상태 혹은 준비상태의 프로세스들을 정리하기 위해 큐(Queue) 사용
    - 대기 큐
        
        : 같은 입출력을 요구한 프로세스 끼리 구분
        
    - 준비 큐
        
        : 우선순위에 따라서 여러 개의 큐로 구분(4장)
        
        ![KakaoTalk_20220725_193739604_01.jpg](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/4.jpg?raw=true)
        
- **프로세스 상태**: 현재 프로세스의 상태를 표현 → Ex. 생성, 준비, 실행, 대기…
- **프로세스 구분자(PID)**: 프로세스의 아이디
- **프로그램 카운터**: 다음 실행할 명령어의 위치를 가리킴
- **프로세스 우선순위**: 프로세스에 우선순위를 가리킴
    - 단순히 모든 프로세스 준비 큐에 들어가서 순서대로 실행되는게 아니라
    - 우선순위가 높은 프로세스는 더 먼저, 더 자주 실행됨
- **레지스터 정보**: 프로세스가 실행되는 중에 사용했던 레지스터의 중간값 보유
- **메모리 관리 정보**
    - 위치 정보: 프로세스가 메모리에 어디에 저장되어 있는지
    - 경계/한계 레지스터 값: 메모리 보호
    - 세그먼테이션 테이블/페이지 테이블
        - 하나의 프로세스를 불연속적으로 메모리에 업로드
        - [메모리페이지, 실제 메모리 주소]
- **할당된 자원 정보**: 입출력 자원, 오픈 파일, 사운드 카드 등의 할당자원 정보
- **계정정보** : 계정번호, CPU할당시간, CPU사용시간
- **부모 프로세스(PPID)와 자식 프로세스(CPID) 구분자**

---

## 2. 문맥 교환

: CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업 = 시분할

: 이 과정에서 PCB가 변경됨

- **완료되는 프로세스**
    - 지금까지의 작업 내용을 PCB에 저장
- **시작되는 프로세스**
    - 저장되었던 PCB정보로 CPU가 셋팅

![KakaoTalk_20220725_193739604.jpg](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/5.jpg?raw=true)

문맥교환이 일어나는 경우는 다양함

- 기본적으로 할당된 시간이 다했을 경우
- 인터럽트가 걸렸을 때에도 발생
    - 입출력 대기(싱글스레드의 경우)
    - 할당된 메모리를 벗어난 경우 → 인터럽트 관리 프로세스가 동작해서 프로세스 강제 종료

----

![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/6.png?raw=true)

- 코드 영역
    - 프로그램의 본문이 있다.
    - 읽기 전용이다
- 데이터 영역
    - 변수나 , 파일 등 각종 데이터가 있다
    - 읽기 쓰기 대부분 가능 (상수로 선언된 것 제외)
    - 일반 데이터 영역
    - 힙 영역
- 스택영역
    - 부수적으로 필요한 데이터

![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/7.png?raw=true)

### Fork()란?

- 프로세스를 복사 하는 함수이다!
- 기존의 프로세스는 부모 프로세스 , 새로 생긴 프로세스는 자식 프로세스이다
- 부모의 CPID와 자식의 PPID가 설정된다.
- 장점
    - 프로세스 생성 속도가 빠르다
    - 추가 자원 없이 자원 상속 가능
    - 시스템 관리를 효율 적으로 할 수 있음

### exec()란?

- 하나의 프로세스를 프로세스의 구조체는 유지한 채 다른 프로세스로 전환 하는 것이다.
- GC를 하지 않아도 된다, 운영체제의 작업이 수월해진다
- PID,PPID,CPID는 유지 된 채로 코드,데이터,스택 영역, 레지스터 값들을 바꾼다.

### 프로세스 계층 구조

- 계층구조의 장점
    - 동시에 여러 작업을 처리할 수 있다
    - 종료된 프로세스의 자원을 회수하는 데에 유용하다
    - 예시→ 책
    - 좀비 프로세스

## 이 모든것은 현대 객체지향 프로그래밍 언어의 기본…!!!

![Untitled](https://github.com/zzun-d/TIL/blob/master/%EC%89%BD%EA%B2%8C%20%EB%B0%B0%EC%9A%B0%EB%8A%94%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/assets/8.png?raw=true)

---

### 스레드의 개념

1. 스레드의 정의
    
    프로세스의 작업 과정 
    
    1. 코드+데이터를 메모리에 가져옴
    2. 프로세스 제어 블록 생성
    3. 작업에 필요한 메모리 영역 확보
    4. 준비된 프로세스를 준비된 큐에 삽입
    5. 프로세스 생성시 CPU 스케쥴러가 해야할 일을 CPU에 전달
        
        전달되는 것 하나가 스레드
        
        → 프로세스의 코드에 따라 CPU에 작업 요청하는 실행 단위
        
        **프로세스 내에서 실행되는 흐름의 단위**
        
        프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개 동시에 실행시킬 수 있는 것
        
2. 프로세스와 스레드의 차이
    
    **프로세스와 스레드의 다른점**
    
    프로세스 = 하나의 목표 // 스레드는 목표를 달성하기 위한 작업
    
    프로세스끼리는 약하게 연결 ⇒ 왜, 와이 : 서로 다른 작업일 수도 있기 때문
    
    스레드끼리는 강하게 연결 ⇒ 하나의 프로세스를 위한 밑작업
    
3. 스레드 관련 용어
    
    멀티스레드, 멀티태스킹, 멀티프로세싱, CPU멀티스레드
    
    1. 멀티스레드 - 프로세스 내 작업을 여러 개의 스레드로 분할, OS가 주체, SW적
    2. 멀티태스킹 - 시분할 시스템을 활용한 기법, CPU에게 OS가 명령을 내리는거
    3. 멀티프로세싱 - CPU, 코어, 컴퓨터를 여러 개 사용하여 여러 개의 스레드를 동시에 처리
        
        → 슈퍼스칼리 기법 : 코어를 여러개 사용하여 병렬처리
        
    4. CPU멀티스레드 - 파이프라인 기법 사용, CPU가 주체, HW적
    

멀티태스킹이 하나의 운영 체제 안에서 여러 프로세스가 실행되는 것

멀티스레드는 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것을 의미

★ 프로그램 → 프로세스 → 스레드

프로그램 : 코드랑 데이터

프로세스 : 프로그램이  실행되어 메모리에 올라가있는 동적인 상태

스레드 : 프로그램에게 할당된 프로세스는 한정되어있기 때문에 더 작은 단위로 작업을 처리하기 위한 단위

파이썬에서 스레드는 비동기 프로그래밍에서 쓰임

**asyncio 모듈**

### 멀티스레드의 구조와 예

1. 멀티스레드의 구조
    
    스레드의 생성과 구성
    
    C언어 이야기 - fork를 통해 스레드를 만들 경우, 코드, 프로세스 제어 블록, 공유변수가 중복됨
    
    프로세스 -  정적인 영역 / 동적인 영역
    
    1. 정적인 영역 : 프로세스가 실행되는 동안 바뀌지 않는 영역
    2. 동적인 영역 : 스레드가 작업을 하면서 값이 바뀌거나 생성,소멸되는 영역 = 레지스터,스택,힙
2. 멀티스레드 예

### 멀티스레드의 장단점

1. 장점
    1. 응답성 향상 : 다른 스레드가 작업 중이어도 다른 스레드가 작업할 수 있음
    2. 자원공유 : 한 프로세스 내의 자원을 같은 프로세스 내의 모든 스레드가 공유하여 작업 원할
    3. 효율성 향상 : fork와는 달리 자원의 중복을 막음
    4. 다중 CPU 지원 : 다중 CPU가 멀티스레드를 동시에 처리하여 시간 단축
2. 단점
    1. IE는 프로세스에 멀티스레드를 활용해 창을 염 → 하나가 문제생기면 다 닫아야함

### 멀티스레드 모델

커널스레드, 사용자스레드 ⇒ 라이브러리를 활용 가능

1. 사용자 스레드 - 라이브러리 사용함! 커널 입장에선 하나의 프로세스처럼 보임
    
    커널이 하는 일을 라이브러리가 대신 처리
    
    하나의 커널 스레드와 여러개의 스레드가 연결되기에 1 to N 모델
    
    장점! 라이브러리가 스케쥴링하고 정보를 처리해서 문맥 교환이 필요 없음
    
    단점! 1 to N 모델이기에 커널스레드가 대기상태로 들어가면 사용자 스레드 전체가 대기
    
         커널이 사용자 스레드를 하나의 프로세스로 인식하기에 나눌 수 없음
    
         보안에 취약
    
2. 커널 스레드 - 커널이 멀티스레드를 지원, 1 to 1모델
    
    독립적 스케쥴링 가능! ← 특정 스레드가 대기상태가 되어도 다른 스레드는 작업 가능
    
    사용자 스레드와 정 반대
    
3. 멀티레벨 스레드
    
    사용자 + 커널 스레드 혼합. M to N 모델