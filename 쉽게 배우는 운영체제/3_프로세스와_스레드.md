# 1. 프로세스의 개요
## 1.1 프로세스의 개념
- 하나의 작업 단위
- 하나의 프로그램을 사용자가 실행하면 그 프로그램은 프로세스가 됨
- 폰노이만 구조에서 프로그램은 저장장치에 있는 정적인 상태
- 프로세스는 프로그램이 실행을 위하여 메모리에 올라온 동적인 상태


## 1.2 요리 비유
- 레시피 -> 프로그램
- 주문서 -> 실행할 프로그램들의 목록
    - 코스 요리 A
    - 가격
    - 애피타이저(새송이 스프)
    - 메인디쉬(스테이크)
    - 디저트(커피)
- 요리 과정 -> 프로세스
    - 재료손질(버섯, 고기, 원두)
    - 요리
    - 서빙
    - 테이블 정리
<br>

- 일괄 작업 시스템(요리 비유)
    - 테이블이 하나뿐인 식당
    - 주문은 한번에 하나씩만 들어오며 주문된 요리가 모두 완료되어야 다음 주문이 가능
    - 고객이 식사를 다 하고 나가야 새로운 손님의 주문서를 받을 수 있음
    - 효율이 떨어짐(요리사가 노는 시간이 발생)
    <br>

    - 일괄 작업 방식에서 기다리는 손님들에게 미리 주문서를 받는 것을 가정하면
    - 주문 목록이 생성됨
        - 생성된 주문 목록은 먼저 들어온 주문서가 먼저 처리되는 형식(queue)
- 시분할 시스템(요리 비유)
    - 테이블이 여러개인 식당은 한번에 여러 손님을 받을 수 있음
    - 1번 손님이 애피타이저를 먹는동안 2번 손님의 애피타이저 요리
    - 요리사는 1명이지만 손님의 식사시간을 잘 활용하여 한번에 여러명의 손님을 응대 가능
    - CPU가 1대인 컴퓨터에서 여러 프로세스를 동시에 실행하는 원리
- 주문서의 역할
    - 주문서가 주문 목록에 올라오는 것은 요리의 시작(프로세스의 시작)
    - 주문서는 주문 목록에서 대기하거나 요리사에게 넘겨져 요리가 되는 상태 왕복
    - 요리의 모든 작업이 끝나면 주문서 폐기(프로세스 종료)
    
- 시분할 시스템에서 예상치 못한 상황 처리
    - 손님이 주문한 음식의 재료 손질이 덜 된 경우
    - 손질이 끝날 때까지 기다렸다가 요리를 진행하면 비효율적
    - 재료손질이 덜된 주문서는 재료손질이 끝날때까지 잠시 대기목록에 둠
    - 이후 다음 주문서를 처리하며, 재료손질이 끝나면 대기목록에서 다시 주문목록으로
    - 또한, 고객이 요리를 늦게 달라고 요청하거나 주문을 취소할 수도 있음
    - 요리 지연 요청이 들어오면 우선 보류 목록에 추가
    - 보류 목록에 있는 주문서들은 언제 다시 시작될지 모름(폐기 가능성도 있음)

## 1.3 프로그램에서 프로세스로의 전환
- 프로세스는 컴퓨터 시스템의 작업 단위로 task라고도 불림
- 프로그램을 실행하면
- 우선 운영체제는 프로그램을 메모리로 올림
- 동시에 주문서에 해당하는 작업 지시서를 생성
- 작업 지시서 -> 프로세스 제어 블록(Process Contol Block)
- 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 않음
- 프로세스 제어블록
    - 프로세스 구분자
        - 메모리에 존재하는 여러 프로세스를 구분하는 역할
    - 메모리 관련 정보
        - 프로세스가 메모리의 어느 부분에 저장 되어있는지 알아야 CPU가 작업 가능
    - 각종 중간값:
        - 프로세스가 사용했던 중간값이 저장
        - 손님에게 애피타이저가 나갔는지, 재료 손질 중은 아닌지
- 정리하면, 운영체제로부터 프로세스 제어 블록을 얻으면 프로그램 -> 프로세스
- 프로세스 제어 블록이 폐기 된다는 것은 프로세스의 종료를 의미

## 1.4 프로세스의 상태
- 일괄 작업 시스템
    - 프로세스가 생성되고, CPU를 받아 작업을 마치면 종료
    - 생성, 실행, 완료 단계로 이루어짐
- 시분할 작업 시스템
    - CPU의 이동이 빈번하기 때문에 일괄 작업 시스템보다 복잡함
    - 생성, 준비, 실행 완료 단계로 이루어짐
    - 생성
        - 

    


