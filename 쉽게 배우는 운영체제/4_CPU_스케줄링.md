### “CPU라는 전산 자원을 어떻게 스케쥴링 할 것이냐”

스레드/프로세스가 CPU를 선점할 때

**스레드/프로세스 줄 세우기 : 스케쥴링!**

**전체적인 부하 상태를 조절해서 과부하 상태 막기**

job-프로세스-스레드

## **스케줄러**

*프로세스를 스케줄링하기 위한 Queue 에는 세 가지 종류가 존재한다.*

- Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue : Device I/O 작업을 대기하고 있는 프로세스의 집합

각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 **세 가지 종류가** 존재한다.


## 레벨별 스케쥴링 ⭐⭐⭐

식당 관리자의 역할 : OS

| 레벨 1 : 고수준 스케쥴링 (장기, job) | ex) 손님 수를 조절. 가게 정원 20명. |
| --- | --- |
| 레벨 2 : 중간수준 스케쥴링 (중기) | ex) 밖에 줄 서는 사람들 관리 (보류) |
| 레벨 3 : 저수준 스케쥴링 (단기, 프로세스, 스레드)  | ex) 가게에 들어온 20명 관리 |


### **장기스케줄러(Long-term scheduler or job scheduler)**
한정된 메모리에 너무 많은 프로세스들이 올라올 경우에 임시로 대용량 메모리에 저장하고, 여기에 저장되어 있는 프로세스들 중에 어떤 프로세스에 메모리를 할당할 지 결정한다

- 메모리와 디스크 사이의 스케줄링을 담당.
- 프로세스에 memory(및 각종 리소스)를 할당(admit)
- 멀티 프로그래밍 정도 degree of Multiprogramming 제어(실행중인 프로세스의 수 제어)
- 프로세스의 상태 `new -> ready` (in memory)

*cf) 메모리에 프로그램이 너무 많이 올라가도, 너무 적게 올라가도 성능이 좋지 않은 것이다. 참고로 time sharing system 에서는 장기 스케줄러가 없다. 그냥 곧바로 메모리에 올라가 ready 상태가 된다.*

### **중기스케줄러(Medium-term scheduler or Swapper)**

- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
- 프로세스에게서 memory 를 deallocate
- degree of Multiprogramming 제어
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러.
- 프로세스의 상태 `ready -> suspended`

### **단기스케줄러(Short-term scheduler or CPU scheduler)**

- CPU 와 메모리 사이의 스케줄링을 담당.
- Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정.
- 프로세스에 CPU 를 할당(scheduler dispatch)
- 프로세스의 상태 `ready -> running -> waiting -> ready`


## 스케쥴링의 목표

- 공평성
- 효율성
- 안정성
- 확장성
- 반응 시간 보장
- 무한 연기 방지


## 스케쥴링 우선순위

- 5단계 : 매우높음 / 약간높음 / 보통 / 약간낮음 / 매우낮음
    - ex) 매우 높음 : 고화질 미디어 플레이어
        
        → 보통 전면(GUI)에서 작동되는 것 (사용자 눈에 보이는 것.)
        
    - ex) 매우 낮음 : 압축 해제
        
        → 보통 후면(백그라운드)로 작동되는 것 (사용자 눈에 안 보이는 것.)
        
    

cf) CPU에 비해 입출력은 느리다. 사용자를 위해 느려도 화면 처리는 빨리 되어야 함. 그래서 비동기 처리가 중요하다.

### 프로세서 사용 계획 항목


ex) 가정용 pc는 프로그램에 체크. 입출력이 중요함.

ex) 서버일 경우 백그라운드 서비스에 체크. 입출력 데이터가 굉장히 많지만 바로 보여줄 필요가 없음. 백그라운드가 더 중요함.

### 우선순위 정리

우선순위 높음

커널 프로세스 (IOCP ← 커널이 직접 개입)

전면 프로세스 (GUI)

대화형 프로세스 (대화상자)

입출력 집중 프로세스


## 선점형 스케쥴링과 비선점형 스케쥴링

- 선점형 스케쥴링 (Preemtive) - 일반적
    - 엑셀이 선점하여 쓰려고 할 때 그걸 OS가 통제할 수 있음
    - 엑셀 실행/ 워드 wait →**OS**→ 엑셀 wait / 워드 실행
    
- 비선점형 스케쥴링 (Non-Preemtive)
    - 한번 실행하면 끝날 때까지 기다림.
---
# 스케줄링 시 고려 사항


- CPU 스케줄러가 프로세스에 CPU를 할당 할 때 고려해야 할 사항을 알아보자

## 1. 선점형, 비선점형 스케줄링

- **선점형 스케줄링**
    - 선점하다 : 남보다 앞서서 차지하다
    - CPU를 할당받아 실행 중인 프로세스에게서 운영체제가 강제로 CPU를 빼앗을 수 있는 방식
    - 시분할 시스템에서 사용
    - 문맥 교환으로 인한 작업 낭비가 있음
    - 중요도가 높다
        - 비선점형, 선점형 두 스케줄링이 있을 때, 일반적으로 선점형이 먼저 실행된다
    - 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용
- **비선점형 스케줄링**
    - 어떤 프로세스가 CPU를 할당받아 사용 중이면 그 프로세스가 종료 상태 혹은 자발적으로 대기 상태에 들어가기 전까지는 다른 프로세스가 CPU를 빼앗아 올 수 없다.
    - 일괄 작업 시스템에서 사용
    - 문맥 교환이 없어 부가적인 작업 낭비가 없음
    - CPU 사용 시간이 긴 프로세스가 CPU를 사용하는 동안 CPU 사용 시간이 짧은 다른 프로세스들이 오랫동안 기다리게 되어 시스템 처리율이 떨어짐
    

## 2. 프로세스 우선순위

- 프로세스의 우선순위는 중요도로 결정된다
    - 중요도가 높으면 우선순위도 높고, 중요도가 낮으면 우선순위가 낮다
- 중요도가 모두 같다는 의미는 우선순위가 존재하지 않음을 의미한다.
- 대부분의 CPU 스케줄러는 우선순위를 사용
- 커널 프로세스가 일반 프로세스보다 우선순위가 높다
    - 같은 커널 프로세스 간에도 우선순위가 존재하며 일반 프로세스도 마찬가지
    - 예를들면, 워드프로세서, 비디오 플레이어 중에는 비디오 플레이어의 우선순위가 더 높다
    - 워드프로세서에서는 사람이 타이핑하는 속도가 CPU 연산속도 보다 느리지만,
    - 비디오 플레이어는 실시간으로 데이터를 읽어와서 영상과 소리를 송출해야 끊김이 없다
    
- 우선순위가 높으면 더 자주 실행된다는 것을 의미함
- 유닉에서 사용자가 일반 프로세스의 우선순위를 조절할 수 있는데,
    - nice 명령어를 통해 우선순위를 낮추거나, 높일 수 있다(높이는 건 관리자만 가능)

## 3. CPU 집중 프로세스와 입출력 집중 프로세스

- 프로세스는 실행 상태와 대기 상태에서 작업이 일어난다.
    - CPU를 할당받아 실행하는 작업을 CPU 버스트
    - 입출력 작업을 입출력 버스트라고 한다.
- CPU 집중 프로세스
    - 수학 연산 처럼 CPU를 많이 사용하는 프로세스
- 입출력 집중 프로세스
    - 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스
- CPU 집중 프로세스와 입출력 집중 프로세스가 공존 하는 경우에 입출력 집중 프로세스에 CPU를 먼저 할당 하는 것이 효율적이다.
    - CPU 집중 프로세스에 먼저 할당
    
    **CPU 집중 프로세스**       ←———CPU———→←-입출력-→←—-CPU—-→
    
    **입출력 집중 프로세스**                                      ←—CPU—→←——-입출력——-→←—CPU—→
    
    - 입출력 집중 프로세스에 먼저 할당
    
    **입출력 집중 프로세스**   ←—CPU—→←——-입출력——-→←—CPU—→
    
    **CPU 집중 프로세스**                           ←———CPU———→←-입출력-→←—-CPU—-→
    

## 4. 전면 프로세스와 후면 프로세스

- 전면 프로세스
    - GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스
    - 현재 입, 출력을 사용하는 프로세스로 사용자와 상호작용이 가능한 상호작용 프로세스
    - 예시) 워드 프로세서
- 후면 프로세스
    - 사용자와 상호작용이 없는 프로세스로 사용자의 입력이 필요 없기 떄문에 일괄 작업 프로세스 라고도 한다.
    - 예시) 압축 프로그램
- 전면 프로세스는 사용자의 요구에 즉각 응답해야 하므로 후면 프로세스보다 우선순위가 높음

## 5. 정리

| 우선순위 높음 | 우선순위 낮음 |
| --- | --- |
| 커널 프로세스 | 일반 프로세스 |
| 전면 프로세스 | 후면 프로세스 |
| 대화형 프로세스 | 일괄 처리 프로세스 |
| 입출력 집중 프로세스 | CPU 집중 프로세스 |

----
### 1. 준비 상태의 다중 큐

- 우선순위가 높은 프로세스에게 더 자주 CPU 할당
    - 프로세스 우선순위(중요도) → PCB
- 우선순위에 따라 **여러 개의 큐(대기열)**
    - 스케쥴링 알고리즘(다음 절)
        - 준비 큐를 몇 개로 분류할 지
        - 여러 개의 준비 큐 중 어떤 프로세스에게 CPU를 할당 할지

- 우선순위의 종류
    - 고정 우선순위
        
        프로세스 생성 시 운영체제에게 우선순위를 부여 받은 후, 프로세스가 끝날 때 바뀌지 않음
        
    - 변동 우선순위
        
        프로세스 작업 중간에 우선순위가 바뀜 → 시스템 효율성 증가
        
        - 우선순위가 낮지만 특정 할당 자원을 독점하는 프로세스 P1이 있을 경우, 우선순위를 높여서 프로세스를 빨리 끝내버림


### 2. 대기 상태의 다중 큐

- 대기를 기다리는 입출력 장치에 따라 **여러 개의 큐(대기열)**
    - 입출력 장치의 완료 인터럽트가 도착하면, 해당 큐의 프로세스를 준비상태로 이동시킴
    - 입출력장치는 CPU나 메모리보다 느리기 때문에, 작업 속도를 높이기 위해 작업 순서를 바꿀 수도 있음
    

    
    - 인터럽트
        - CPU가 주기적으로 입출력장치를 확인 → 입출력장치가 CPU에게 인터럽트 신호를 전송
    - 인터럽트 벡터
        - 여러 입출력장치에서 동시 발생하는 인터럽트를 처리
    
---


### 스케쥴링 알고리즘 성능 척도

- CPU 사용률
- 처리량
- 대기 시간
- 응답 시간
- 반환 시간

## FCFS (First come first served)

먼저 온 순서대로 처리해준다

그렇게 효율적이진않는다 

- 성능
    - waiting time : 앞에 긴 burst time을 가진 프로세스가 오면 비효율적 반대면 효율적


### SJF(Shortest Job First)

CPU burst 시간이 가장 작은 프로세스를 가장 먼저 스케쥴

- 성능
    - average waiting time이 가장 optimal이다 (preemptive하고 nonpreemptive하고 중에서는 preemptive가 더 짧긴 함)
- Nonpreemptive (비선점형)
    - 완료할 때 까지 안 줌
- Preemptive (선점형)
    - 만약 지금 수행중인 프로세스보다 burst time이 짧은 CPU burst time을 가지는 프로세스가 도착한다면 CPU를 빼앗김 (SRTF)
- 문제점
    - cpu 사용시간이 긴 process는 기다리는 시간이 너무 길다  (starvation)
    - CPU 사용 시간을 사실 실행 시점에 미리 알 수 없다는게 문제다
        - 예측이 가능하긴 함 (과거에 얼마나 썼는지)
        - exponential averaging
        - 최근의 것의 가중치가 더 높다

    
    

### HRN(Highest response ratio next)

최고 응답률 우선 스케쥴링

우선순위 = (대기시간 + cpu burst time) / (cpu burst time)

(우선순위 스케쥴링의 일종)


### Round robin (RR)

각 프로세스는 동일한 크기의 할당 시간을 가짐 (일반적으로 10 ~ 100 ms)

할당시간이 끝나면 프로세스는 preempted 당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다

- 장점
    - 응답시간이 빠르다 (누구나 일정한 시간 이상 기디리지 않는다)
        - n개의 ready queue가 있고 할당 시간이 q라면 , (n-1)q 이상 기다리지 않는다
        - q값이 작으면 작을 수록 위의 값이 작아질 것이다
    - CPU 사용시간이 적은 (i/o bound)한 process가 빨리 쓰고 나가게 해준다
- 특징
    - 각 프로세스의 waiting time은 그 프로그램의 cpu burst time에 비례한다
- 성능
    - q가 커질수록 FCFS와 비슷해지고 q가 작을 수록 context switch 오버헤드가 커진다
    - 일반적으로 SJF보다 average turn around time은 길지만 response time은 더 짧다

cpu burst time이 짧고 긴 것들이 섞여있고 각 프로세스마다의 cpu burst time을 예측할 수 없을 때 좋다 


### SRT(Shortest remaining time)

최소 잔류 시간 우선 스케쥴링 (SJF 스케쥴링의 선점형 방식) (SRT의 preemptive 버전)


### Priority Scheduling

우선순위가 높은 프로세스에게 CPU를 할당! (우선순위의 숫자 값이 낮다 = 순위가 높다!)

우선순위는 어떻게 정하나?! → 여러 기준을 사용할 수 있음 

사실 SJF도 우선순위 스케쥴링의 일종이다! (우선순위를 CPU burst time을 기준으로 한 것!)

- 문제점
    - Starvation
        - 이것의 solution ⇒ aging
            - aging이란 시간이 지날 수록 process의 우선순위를 높인다!


### Multilevel Queue

여러줄로 process가 기다림!!


- Ready queue를 여러 개로 분할
    - foreground (interactive)
    - background (batch - no human interaction)
- 각 큐는 독립적인 스케쥴링 알고리즘을 가짐
    - foreground - RR
    - background - FCFS
- 큐에 대한 스케쥴링이 필요
    - Fixed priority scheduling
        - serve all from foreground then from background
        - Possibility of starvation
    - Time slice
        - 각 큐에 CPU time을 적절한 비율로 할당
        - Eg, 80% to foreground in RR , 20% to background in FCFS
    
    

### Multilevel Feedback Queue

위에서 본 것에서 프로세스가 다른 큐로 이동 가능 한 방법이다

q1 - 커널 프로세스가 하는 중요한 일들 

q2 - RR timeslice 8

q3 - RR timeslice 16

q4 - 32

q5 - 무한대 (FCFS)

점점 낮은 큐로 이동한다. 보통 우선순위가 낮은 큐의 time slice가 크다 (겨우 힘들게 얻었을 테니까)

---

# 인터럽트의 개념

1. 순차적 프로그래밍 → 한줄씩 차례로 실행 ⇒ 지금 파이썬에서 하는 프로그래밍과 같음
    
    → 특정 문제를 해결하는데 취약한 단점이 있음
    
    ### 크롬 닫기 문제
    
    크롬의 우측 상단에 보면 탭이동 버튼 ∨
    
    최소화 버튼 ㅡ
    
    창모드 버튼
    
    종료 버튼 X
    
    순차적 프로그래밍에서는 주기적으로 이 버튼들의 상태를 체크해야하는 비효율적인 방식
    
    오늘날의 프로그래밍에서는 주기적으로 확인하는 대신 버튼이 눌리면 프로세스에 알려주는 이벤트 드리븐(event driven)방식을 사용
    
    운영체제에서의 입출력 처리도 유사함
    
    과거에는 **순차적 프로그래밍**처럼 입출력장치를 **직접 확인**해서 처리 = 폴링 방식
    
    점차 입출력장치가 다양해짐에 따라 폴링 방식이 어려워졌고 이벤트 드리븐 방식과 유사한 방식을 사용하기 시작함 = 인터럽트
    
    파이썬 코드에서
    
    ```python
    while True:
    	print('hello, world!')
    ```
    
    를 실행시 무한정 반복되만 Ctrl + C누르면 멈춘다 → 이것도 인터럽트
    
    즉, 인터럽트는 CPU에서 입출력관리자와 하는 상호작용, 입출력처리 외에도 종류가 다양하고 광범위하게 쓰임
<br>

    
2. 동기적 인터럽트(=사용자 인터럽트)
    1. 프로그램상의 문제로 발생하는 인터럽트(다른 사용자의 메모리 침범, 오버플로, 언더플로)
        
        오버플로 = 컴퓨터의 정수 연산의 계산 결과가 허용 범위를 초과할 때 발생하는 오류
        
        언더플로 = 음수로 표현 가능한 범위를 초과하면 나옴
        
    2. 작업자가 의도적으로 프로세스 중단을 위해 발생시킨 인터럽트 (ctrl + c)
    3. 입출력장치 같은 주변장치 조작에 의한 인터럽트
    4. 산술 연산 중 발생하는 인터럽트 (0으로 나누기)
    <br>

3.  비동기적 인터럽트
    
    하드웨어적인 오류로 발생하는 인터럽트
    
    1. 키보드 인터럽트 → 키보드 누르는 순간순간이 인터럽트임
    2. 마우스 인터럽트 → 이하동문
<br>

4. 인터럽트 처리 과정
    
    인터럽트 종류에 따라 번호(IRQ)가 저장되어있음
    
    IRQ에 따라 어떻게 처리할지 이미 정해져 있음
    
    - 인터럽트 벡터
    
    인터럽트 핸들러 : 인터럽트 벡터에 연결된 인터럽트를 처리하는 함수
    
<br>

5. 인터럽트와 이중 모드
    
    커널 모드와 사용자 모드
    
    사용자 모드에서 입출력, 프로세스 생성과 같은 커널영역의 기능을 사용하려면 시스템 호출을 이용하여 커널 프로세스에 작업을 요청 → 사용자 프로세스는 대기상태로 전환
    
    이중모드는 사용자 프로세스가 시스템 자원에 직접 접근하면 생길 문제를 막기 위해 시스템 호출을 통해서 자원을 접근하게 하는 것
    
    → 사용자 프로세스가 커널 모드에서 실행되지 못하게 하는 것
    
    → 챕터 1에서 OS의 역할 중 자원보호
    
    시스템 호출을 편하고 쉽게 이용하기 위해 API를 제공

    <br>
    
    **MFC(Microsoft Foundation Class Library)**
    
    마이크로 소프트에서 만든 Window API를 C++로 둘러싼 Library
    
    사용자 프로세스가 커널 모드로 진입하는 경우는 두 가지
    
    1. 시스템 호출 사용 → 자발적
    2. 인터럽트를 발생 → 비자발적