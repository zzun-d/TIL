# 1. 컴퓨터의 기본 구성
## 1.1 하드웨어의 구성
- 필수장치
    - 중앙처리장치(CPU)
    - 메인메모리(RAM)

- 주변장치
    - 입력장치(키보드, 마우스)
    - 출력장치(모니터, 프린터)
    - 저장장치(하드디스크, 플로피디스크)

- CPU
    - 명령어를 해석하고 실행하는 장치
    - 인간의 두뇌 역할
- 메인메모리
    - 작업에 필요한 프로그램, 데이터를 저장하는 장소
    - byte 단위로 분할되어 있으며, 분할된 공간마다 주소로 구분
- 입력장치
    - 외부의 데이터를 컴퓨터에 입력하는 장치
    - 초기에는 천공카드 -> 현재 키보드, 마우스, 스캐너, 터치스크린
- 출력장치
    - 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력하는 장치
    - 프린터, 모니터, 스피커
- 저장장치
    - 메모리는 전자의 이동으로 데이터 처리
        - 빠르고 비싸다
    - 하드디스크, CD와 같은 저장장치는 구동장치로 작동
        - 느리고 싸며, 용량이 크고, 전원 유무에 관계없이 데이터를 영구 저장
    - 자성을 이용하는 저장장치
        - 카세트테이프, 플로피디스크, 하드디스크
    - 레이저를 이용하는 저장장치
        - CD, DVD, 블루레이디스크
    - 메모리를 이용하는 저장장치
        - USB 드라이버, SD 카드, SSD 등
<br>

- 메인보드
    - CPU와 메모리 등 다양한 부품을 연결하는 커다란 판
    - 컴퓨터의 부품들은 메인보드위에 가는 선(버스)로 연결
    - 각종 부품을 꽂을 수 있는 단자가 존재하여 그래픽카드, 사운드카드, 랜카드등을 장착할 수 있음

## 1.2 폰노이만 구조
- CPU, 메모리, 입출력장치, 저장장치가 버스로 연결된 구조
- **모든 프로그램은 메모리에 올라와야 실행이 가능**
- 운영체제도 마찬가지

## 1.3 하드웨어 사양 관련 용어
- 클록
    - CPU 속도와 관련된 단위
    - CPU는 작업 일정 간격으로 틱(tick)을 만들고, 이 틱에 맞춰 모든 구성품이 작업을 진행
    - 메인보드의 클록이 틱을 보낼 때마다 데이터를 주거나 받는다
- 헤르츠
    - 클록틱이 발생하는 속도를 나타낸 단위로
    - 1초에 몇번 클록틱이 발생하는지를 나타냄
- 시스템 버스와 CPU 내부 버스
    - 시스템 버스는 메모리와 주변장치를 연결하는 버스로 전면 버스라고도 함
    - CPU 내부 버스는 CPU 내부에 있는 장치를 연결하는 버스로 후면 버스라고도 함
    - CPU는 CPU 내부 버스의 속도로 작동하고, 메모리는 시스템 버스의 속도로 작동
    - 두 버스의 속도 차이로 작업이 지연되는 문제가 발생

# 2. CPU와 메모리
## 2.1 CPU의 구성과 동작
- CPU 기본 구성
    - 산술논리 연산장치, 제어장치, 레지스터로 구성되며 이것들의 협업으로 작업 처리
    - 산술논리 연산장치
        - 데이터의 덧셈, 뺄셈, 곱셈, 나눗셈, AND, OR 등의 연산 수행
    - 제어장치
        - CPU에서 작업을 지시하는 부분
    - 레지스터
        - 데이터를 임시로 보관하는 곳
- CPU의 명령어 처리 과정
    ```python
    D2 = 2
    D3 = 3
    sum_D2_D3 = D2 + D3
    ```
    위 코드는 D2에 저장된 값, D3에 저장된 값 두 개를 더하여 sum_D2_D3에 넣으라는 의미이다
    CPU는 2진수로 이루어진 기계어만 인식하기 때문에, 컴파일러를 이용하여 기계어로 변환해야 한다.
---
### CPU의 기본 구성

- 산술논리 연산 장치 (ALU)
    - 데이터를 연산하는 장치, 여러 산술 연산과 논리 연산을 수행함
- 제어장치
    - CPU에서 작업을 지시하는 부분을 제어장치라고 함
- 레지스터
    - CPU내에 데이터를 임시로 보관하는 곳을 레지스터라고 한다

### CPU 명령어 처리 과정

- C언어와같은 high level 언어는 이해하지 못하고 보통 이것이 어셈블리 언어로 바뀌고 이러한 어셈블리 언어가 기계어로 바뀌고 CPU에게 읽힌다.
- 실제로 처리되는건 어셈블리어에서 말하는 것 그대로 실행 되므로 어셈블리어를 보면 어떻게 명령어가 실행되는지 알 수 있다.

### 레지스터의 종류

- 사용자 레지스터
    - 데이터 레지스터
    - 주소 레지스터
- 특수 레지스터 (사용자 불가시 레지스터)
    - 프로그램 카운터
    - 명령어 레지스터
    - 메모리 주소 레지스터
    - 메모리 버퍼 레지스터

### 버스의 종류

- 제어버스
    - 어떤 작업을 할 지 지시하는 제어신호가 오고감
    - CPU의 제어장치, 주변장치, 메모리와 연결되어있음
- 주소버스
    - 주소(위치)정보들이 오고간다. 단방향으로 메모리,주변장치와 연결되어있으며, 메모리 주소 레지스터가 주소버스에 정보를 주고, 그 정보들이 주소버스를 통해 주변장치,메모리로 간다
- 데이터 버스
    - 메모리,메모리버퍼레지스터,주변장치와 연결되어있으며 데이터가 오고감

### 메모리 종류

- 램
    - 휘발성
        - DRAM
        - SRAM
        - SDRAM
    - 비휘발성
- 롬

### 메모리 보호

운영체제도 결국 프로그램의 한 종류이므로 CPU가 사용자의 작업을 진행하는 동안에는 운영체제는 동작하지 않는다. 그렇다면 사용자 작업이 범위를 벗어나서 다른 프로그램이 차지하고있는 메모리를 침범하면 안될 것이다. 따라서 경계,한계 레지스터에 메모리주소 값 , 차이를 저장해서 사용한다.

### 부팅

1. 전원 킴
2. 롬에 저장 된 바이오스 실행 
3. 바이오스가 하드웨어 (메모리,cpu,하드디스크,마우스 등) 작동하는지 확인
4. 하드디스크의 마스터 부트 레코드에 저장된 작은 프로그램을 메모리로 가져와 실행
5. 마스터 부트 레코드가 메모리에 올라오면, 하드디스크에 저장된 운영체제를 메모리로 불러옴
6. 운영체제 실행!

---
## 버퍼

1. 캐시 - 속도에 차이가 있는 두 장치 사이에서 차이를 완화하는 역할
ex) 눈싸움
눈 결정 하나하나 던지기 vs 눈 뭉쳐서 던지기
    
    
    느린 입출력장치에서 데이터를 읽을 때마다 전송하는 것보다 일정량의 데이터를 모아 전송하면 효율적
    
    유튜브보다 보면 10초 재생하고 멈추고 10초 재생하고 멈추고 이러는데 이런식으로 1프레임 단위로 보내는 것이 아니라 일정량 모으고 보내주는 거임
    
    
    
2. 스풀
CPU와 입출력장치가 독립적으로 동작하도록 고안된 SW BUFFER

    
    - 프린터 스풀러
    
    인쇄할 내용을 순차적으로 출력하는 SW, 출력 명령을 내린 프로그램과 독립적으로 동작함
    스풀러가 있기에 한글 파일을 인쇄하고 여기에 다시 작업해도 작업 가능
    
    - 버퍼와 스풀러
        1. 버퍼는 어떤 프로그램의 데이터던 버퍼가 차면 이동
        2. 스풀러는 인쇄 중 다른 문서를 인쇄해도 끼어들 수 없고 차례대로 인쇄함
    

## 캐시

1.  캐시의 개념
캐시는 MEMORY와 CPU 간 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 장소

즉, CPU가 미리 사용할 것 같은 데이터를 미리 가져다 놓는 장소

    
    ex) 간장이야기
    지금 당장 간장 10cc가 필요해서 장독대에 가서 간장 10cc만 가져오는 것보다 미리 여유있게 가져와서 보관해두면 다음에는 장독대에 가지 않아도 된다
    
    MEMORY는 시스템 버스의 속도로 작동하기에 느림
    
    → 빠른 속도의 CPU의 캐시 메모리는 느린 메모리와 속도 차이 완화
    
    CPU는 메모리에 접근 전에 캐시 메모리에 방문하여 데이터를 찾아보고
    
    없다(캐시 미스)면 메모리에 가서 데이터를 찾음 → 일반 컴퓨터의 캐시 적중률은 90%
    
    - 캐시 적중률을 올리는 법
        1. 캐시 메모리를 늘리기 → 비쌈
        2. 많이 사용될 데이터를 가져오는 것 - 지역성이론에 따름(가까울수록 사용될 확률이 높다)
            
            프로그램시 goto문을 사용하지 않는 것이 좋다
            
    
    ### CPU가 예측함으로써 생긴 문제
    
    [https://www.youtube.com/watch?v=Npd77X1MTAo](https://www.youtube.com/watch?v=Npd77X1MTAo)
    
2. 즉시 쓰기와 지연 쓰기
    
    캐시의 데이터가 변경되는 경우 메모리의 원본 데이터도 변경해야함
    
    1. 즉시 쓰기
        
        캐시 데이터가 변경되면 메모리에 즉시 반영
        
        → 속도가 느려지지만 메모리의 데이터가 항상 최신값이 됨(정전에도 데이터를 잃지 않음)
        
    2. 지연 쓰기 (= 카피백)
        
        버퍼처럼 변경된 내용을 모아서 주기적으로 변경
        
        → 성능은 좋아지나 캐시와 메모리의 데이터가 일치하지 않을 수 있음
        
3. L1 L2캐시
    
    캐시는 모든 자료를 가져오는 일반캐시 / 명령어와 데이터를 구분하여 가져오는 특수 캐시
    
    L2 캐시 = 메모리와 연결된 일반 캐시
    
    L1 캐시 = 명령어/데이터 레지스터와 연결된 특수 캐시
    
    최근 L3 캐시 추가
    
    L2와 같은 기능이지만 더 큰 용량, 약간 느린 속도
    
    주로 프로세서의 빅 데이터 처리 성능 향상에 반영되어 게임 성능에 큰 도움
    
4. 파이썬에서 캐시 구현하기
    
    [https://www.daleseo.com/python-cache/](https://www.daleseo.com/python-cache/)
    

## 저장장치의 계층 구조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f71ede94-16a1-4025-899d-27b1b5311783/Untitled.png)

속도가 빠르고 비싼 저장장치를 CPU쪽으로 싸고 용량이 큰 저장장치를 반대에 배치하여 효율을 내는 구조

## 인터럽트

1. 인터럽트의 개념
    
    폴링방식 - CPU가 직접 입출력장치에서 데이터를 송수신
    
    → 효율이 떨어짐..
    
    인터럽트 방식 - CPU의 작업과 저장장치 데이터 이동을 독립적으로 운영
    

1. 동작 과정
    1. CPU가 입출력 관리자에게 입출력 명령을 보냄
    2. 관리자는 명령받은 데이터를 메모리에 올리거나 메모리의 데이터를 저장장치로 옮김
    3. 데이터 전송이 완료되면 관리자는 완료 신호를 CPU에 보냄
    
    c번의 완료 신호 인터럽트라고 함
    
    인터럽트 발생시 CPU는 하던 작업을 중단하고 데이터를 처리
    
    - 컴퓨터 주변 장치는 너무 많기에 인터럽트 번호를 사용함
        
        윈도우에서는 키보드 - 1, 마우스 - 12, 첫번째 하드 - 14
        
    - 인터럽트 벡터
        
        a를 여러개할 수 있는데 여러 작업이 동시에 완료됨 → 비효율적
        
        인터럽트를 하나의 배열로 만든 것이 인터럽트 벡터
        
        한번의 인터럽트 신호로 여러 완료를 처리
        
2. 직접 메모리 접근
    
    메모리는 CPU만 접근 권한을 가짐 → 직접 메모리 접근 권한
    
    따라서 입출력 관리자는 이러한 권한을 가져야 CPU의 개입 없이 메모리에 접근 할 수 있다
    
3. 메모리 맵핑 입출력
    
    그러나 직접 메모리 접근을 사용하면 메모리가 복잡해짐
    
    메모리에는 CPU와 입출력 장치가 사용하는 데이터가 섞여있음
    
    이를 막기위해 메모리를 나누어 사용하는 방법이 도입 → 메모리 맵핑 입출력
    
     이를 사용하면 메모리의 낭비가 없고 효율향상
    
    ### python mmap 함수 - 파이썬의 메모리 맵핑 함수
    

1. 사이클 훔치기
    
    CPU와 입출력장치가 동시에 메모리 접근한다면??
    
    → CPU가 양보함. 이를 사이클 훔치기라고 함

---
# 병렬 처리

## 병렬 처리 개요

CPU 성능을 향상시킬 수 있는 방법 중 병렬처리에 대해 알아본다.

## 병렬 처리 개념

병렬 처리란 동시에 여러 개의 명령을 처리해, 작업의 효율을 올리는 방식.

병렬 처리 방식에는 크게 두 가지가 있다. 

1. 파이프라인 기법
    - 스레드를 늘리는 방식
2. 슈퍼스칼라 기법
    - CPU의 코어를 늘리는 방식

## 병렬 처리 기법

우선 CPU의 제어장치에서 명령어를 처리할 때 어떤 방식을 살펴본다.

명령어 처리 4단계

1. 명령어 패치(IF) : 명령어를 명령어 레지스터에 저장
2. 명령어 해석(ID) : 명령어 해석
3. 실행(EX) : 명령어 실행
4. 쓰기(WB) : 결과 메모리에 저장

IF → ID → EX → WB 를 묶어 ‘스레드’라 한다.

스레드는 CPU 가 처리할 수 있는 작업의 단위이다.

### 파이프라인 기법

명령을 겹쳐서 실행하는 방법. 즉 스레드를 겹쳐서 사용하는 것

하나의 코어에 여러 스레드를 사용하는 것

1   IF → ID → EX → WB 

2           IF → ID → EX → WB

3                    IF → ID → EX → WB

4*                           IF → ID → EX → WB

스레드 4개를 실행하는 모습

파이프라인 기법을 사용하면 최대 동시 처리 명령어의 개수는 4이다. (세로 줄 수)

### 파이프라인 기법을 사용할 때 위험

1. 데이터 위험
    - 데이터 의존성 때문에 발생(각 스레드 간에 의존 관계가 있을 때)
    - 명령어 처리를 지연하여 해결
2. 제어 위험
    - 프로그램 카운터 값을 갑자기 변화시킬 때 발생
    - 분기 예측, 분기 지연 방법으로 해결
3. 구조 위험
    - 서로 다른 명령어가 같은 자원에 접근할 때 충돌하는 것
    - 해결하기 어렵다.

### 슈퍼스칼라 기법

코어를 여러 개 구성하여 복수의 명령어가 동시 실행되게 하는 기법

---

### 슈퍼파이프라인 기법

파이프라인 기법 강화한 것 

더 가깝게 붙인 것

### 슈퍼파이프라인 슈퍼스칼라 기법

슈퍼파이프라인, 슈퍼스칼라 기법 합친 것

### VLIW 기법

완전히 다른 기법

명령어를 컴파일러가 추출 → 하나의 명령어로 압축해서 실행

---
# 1. 무어의 법칙

> 인텔의 공동 창업자 고든 무어 Gordon Moore
> 
> 
> **“CPU의 속도가 24개월마다 2배 빨라진다.”**
> 

- **초기 CPU**에만 적용. 현재는 CPU의 자체 **발열 문제** 때문에 적용 x
- **멀티코어** : CPU의 코어를 여러개 구성. 코어가 8개인 옥타코어가 대중화.
- **멀티스레드** : 하나의 코어에서 여러개의 명령어를 실행하는 기술. 현재 4코어 8스레드 제품이 판매.

# 2. 암달의 법칙

> 진 암달 Gene Amdahl
> 
> 
> **컴퓨터 시스템의 일부를 개선할 때 전체 시스템에 미치는 영향**과의 관계에 대한 수식
> 

- 주변 장치의 향상 없이 CPU의 속도를 2배로 늘려도 성능이 2배 빨라지지 않음.
- 주변장치가 CPU의 발전 속도를 따라가시 못해 전반적인 성능 저하.
- 멀티코어에도 적용됨.